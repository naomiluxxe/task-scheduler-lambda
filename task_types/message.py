"""MESSAGE task type handler.

Sends a message to the target(s) via the assigned agent.
Uses LLM generation via agent_response_generator Lambda,
then sends to Discord via dronebot HTTP endpoint.
"""

import json
import os
import boto3
import logging
import urllib.request
import urllib.error

logger = logging.getLogger(__name__)
lambda_client = boto3.client('lambda', region_name='us-east-1')

# Configuration from environment
DRONEBOT_URL = os.environ.get('DRONEBOT_URL', 'http://localhost:3000')
DRONEBOT_TOKEN = os.environ.get('DRONEBOT_API_TOKEN', '')
RESPONSE_GENERATOR_LAMBDA = os.environ.get('RESPONSE_GENERATOR_LAMBDA', 'void-mother-response-generator')

# Map agent names to their IDs and display names
AGENT_CONFIG = {
    'void-mother': {
        'agent_id': 'void-mother',
        'agent_name': 'Void Mother'
    },
    '0xf100': {
        'agent_id': '0xf100',
        'agent_name': 'Greeter Drone'
    },
    '0xf101': {
        'agent_id': '0xf101',
        'agent_name': 'Propaganda Drone'
    },
}


def handle_message(task, target, channel_id):
    """
    Handle a MESSAGE task with full LLM generation.

    Flow:
    1. Call agent_response_generator Lambda in 'scheduled_task' mode
    2. POST generated message to dronebot HTTP endpoint

    Args:
        task: The task object from DynamoDB
        target: The resolved target (drone ID or user ID)
        channel_id: The Discord channel ID to post in

    Returns:
        dict with success status and any response data
    """
    payload = task.get('payload', {})
    content_prompt = payload.get('content', '')
    agent_params = task.get('agent_params', {})
    assignee = task.get('assignee', 'void-mother')

    if not content_prompt:
        return {
            'success': False,
            'error': 'No message content/prompt provided'
        }

    if not channel_id:
        return {
            'success': False,
            'error': 'No channel_id available (special channel types not yet supported)'
        }

    # Get agent config
    agent_config = AGENT_CONFIG.get(assignee, AGENT_CONFIG['void-mother'])

    # Step 1: Generate response using agent_response_generator
    logger.info(f"Generating message via {RESPONSE_GENERATOR_LAMBDA} for task {task['task_id']}")

    generator_payload = {
        'mode': 'scheduled_task',
        'agent_id': agent_config['agent_id'],
        'agent_name': agent_config['agent_name'],
        'task_id': task['task_id'],
        'task_title': task.get('title', ''),
        'target_id': target,
        'channel_id': channel_id,
        'content_prompt': content_prompt,
        'agent_params': agent_params
    }

    try:
        response = lambda_client.invoke(
            FunctionName=RESPONSE_GENERATOR_LAMBDA,
            InvocationType='RequestResponse',
            Payload=json.dumps(generator_payload)
        )

        result = json.loads(response['Payload'].read())

        if result.get('statusCode') != 200:
            error_body = json.loads(result.get('body', '{}'))
            error_msg = error_body.get('error', 'LLM generation failed')
            logger.error(f"Response generator error: {error_msg}")
            return {'success': False, 'error': f'LLM generation error: {error_msg}'}

        body = json.loads(result['body'])
        generated_message = body.get('response', '')

        if not generated_message:
            return {'success': False, 'error': 'No message generated by LLM'}

        logger.info(f"Generated message ({len(generated_message)} chars) for task {task['task_id']}")

    except Exception as e:
        logger.error(f"Failed to call response generator: {e}")
        return {'success': False, 'error': f'LLM invocation error: {str(e)}'}

    # Step 2: Send to Discord via dronebot HTTP endpoint
    try:
        http_result = send_to_dronebot(
            channel_id=channel_id,
            content=generated_message,
            agent_name=assignee,
            task_id=task['task_id'],
            target=target
        )

        if http_result.get('success'):
            logger.info(f"Message sent to Discord for task {task['task_id']}, message_id={http_result.get('message_id')}")
            return {
                'success': True,
                'agent': assignee,
                'message_id': http_result.get('message_id'),
                'generated_length': len(generated_message)
            }
        else:
            error_msg = http_result.get('error', 'Unknown send error')
            logger.error(f"Failed to send to Discord: {error_msg}")
            return {'success': False, 'error': f'Discord send error: {error_msg}'}

    except Exception as e:
        logger.error(f"Failed to send to dronebot: {e}")
        return {'success': False, 'error': f'HTTP error: {str(e)}'}


def send_to_dronebot(channel_id, content, agent_name, task_id, target):
    """
    Send message to Discord via dronebot HTTP endpoint.

    Args:
        channel_id: Discord channel ID
        content: Message content
        agent_name: Agent that generated the message
        task_id: Task ID for logging
        target: Target user ID

    Returns:
        dict with success status and message_id if successful
    """
    if not DRONEBOT_URL:
        return {'success': False, 'error': 'DRONEBOT_URL not configured'}

    if not DRONEBOT_TOKEN:
        return {'success': False, 'error': 'DRONEBOT_API_TOKEN not configured'}

    payload = json.dumps({
        'channel_id': channel_id,
        'content': content,
        'agent_name': agent_name,
        'task_id': task_id,
        'target': target
    }).encode('utf-8')

    url = f"{DRONEBOT_URL}/task/execute"
    logger.info(f"Sending message to {url}")

    req = urllib.request.Request(
        url,
        data=payload,
        headers={
            'Content-Type': 'application/json',
            'X-Dronebot-Token': DRONEBOT_TOKEN
        },
        method='POST'
    )

    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            result = json.loads(resp.read().decode('utf-8'))
            return result
    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8') if e.fp else str(e)
        logger.error(f"HTTP error {e.code}: {error_body}")
        return {'success': False, 'error': f'HTTP {e.code}: {error_body}'}
    except urllib.error.URLError as e:
        logger.error(f"URL error: {e.reason}")
        return {'success': False, 'error': f'Connection error: {e.reason}'}
