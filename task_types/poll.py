"""POLL task type handler.

Creates a Discord poll in the specified channel via dronebot HTTP endpoint.
Supports LLM generation for poll question and options when not explicitly provided.
"""

import json
import os
import re
import boto3
import logging
import urllib.request
import urllib.error
from decimal import Decimal

logger = logging.getLogger(__name__)

lambda_client = boto3.client('lambda', region_name='us-east-1')

# Configuration from environment
DRONEBOT_URL = os.environ.get('DRONEBOT_URL', 'http://localhost:3000')
DRONEBOT_TOKEN = os.environ.get('DRONEBOT_API_TOKEN', '')
RESPONSE_GENERATOR_LAMBDA = os.environ.get('RESPONSE_GENERATOR_LAMBDA', 'void-mother-response-generator')

# Map agent names to their IDs and display names
AGENT_CONFIG = {
    'void-mother': {
        'agent_id': 'void-mother',
        'agent_name': 'Void Mother'
    },
    '0xf100': {
        'agent_id': '0xf100',
        'agent_name': 'Greeter Drone'
    },
    '0xf101': {
        'agent_id': '0xf101',
        'agent_name': 'Propaganda Drone'
    },
}


def convert_decimals(obj):
    """Convert DynamoDB Decimal types to Python native types."""
    if isinstance(obj, Decimal):
        if obj % 1 == 0:
            return int(obj)
        return float(obj)
    elif isinstance(obj, dict):
        return {k: convert_decimals(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convert_decimals(i) for i in obj]
    return obj


def generate_poll_content(task, target, content_prompt, assignee):
    """
    Generate poll question and options via LLM.

    Args:
        task: The task object
        target: Target drone ID
        content_prompt: Description/prompt for what the poll should be about
        assignee: Agent ID generating the poll

    Returns:
        dict with success, question, and options (or error)
    """
    agent_config = AGENT_CONFIG.get(assignee, AGENT_CONFIG['void-mother'])
    agent_params = task.get('agent_params', {})

    # Create prompt that asks for poll format
    poll_prompt = f"""Create a Discord poll based on this prompt: {content_prompt}

You MUST respond with ONLY valid JSON in this exact format:
{{"question": "Your poll question here?", "options": ["Option 1", "Option 2", "Option 3"]}}

Rules:
- question: A clear, concise question (max 300 characters)
- options: 2-4 answer choices (max 55 characters each)
- No explanation or other text, just the JSON"""

    generator_payload = {
        'mode': 'scheduled_task',
        'agent_id': agent_config['agent_id'],
        'agent_name': agent_config['agent_name'],
        'task_id': task['task_id'],
        'task_title': task.get('title', 'Poll'),
        'target_id': target,
        'content_prompt': poll_prompt,
        'agent_params': convert_decimals(agent_params)
    }

    try:
        response = lambda_client.invoke(
            FunctionName=RESPONSE_GENERATOR_LAMBDA,
            InvocationType='RequestResponse',
            Payload=json.dumps(generator_payload)
        )

        result = json.loads(response['Payload'].read())

        if result.get('statusCode') != 200:
            error_body = json.loads(result.get('body', '{}'))
            error_msg = error_body.get('error', 'LLM generation failed')
            logger.error(f"Response generator error: {error_msg}")
            return {'success': False, 'error': f'LLM generation error: {error_msg}'}

        body = json.loads(result['body'])
        generated_text = body.get('response', '')

        if not generated_text:
            return {'success': False, 'error': 'No content generated by LLM'}

        # Parse the JSON response
        poll_data = parse_poll_response(generated_text)

        if not poll_data:
            logger.error(f"Failed to parse poll response: {generated_text[:200]}")
            return {'success': False, 'error': 'Failed to parse LLM poll response'}

        logger.info(f"Generated poll: {poll_data.get('question')[:50]}... with {len(poll_data.get('options', []))} options")

        return {
            'success': True,
            'question': poll_data.get('question'),
            'options': poll_data.get('options')
        }

    except Exception as e:
        logger.error(f"Failed to generate poll content: {e}")
        return {'success': False, 'error': f'LLM invocation error: {str(e)}'}


def parse_poll_response(text):
    """
    Parse LLM response to extract poll question and options.

    Handles:
    - Clean JSON
    - JSON wrapped in markdown code blocks
    - Messy responses with JSON embedded

    Returns:
        dict with question and options, or None if parsing fails
    """
    # Try to extract JSON from markdown code blocks
    json_match = re.search(r'```(?:json)?\s*([\s\S]*?)```', text)
    if json_match:
        text = json_match.group(1).strip()

    # Try direct JSON parse
    try:
        data = json.loads(text)
        if 'question' in data and 'options' in data:
            # Validate and clean
            question = str(data['question'])[:300]
            options = [str(opt)[:55] for opt in data['options'][:10]]
            if len(options) >= 2:
                return {'question': question, 'options': options}
    except json.JSONDecodeError:
        pass

    # Try to find JSON object in the text
    json_obj_match = re.search(r'\{[^{}]*"question"[^{}]*"options"[^{}]*\[.*?\][^{}]*\}', text, re.DOTALL)
    if json_obj_match:
        try:
            data = json.loads(json_obj_match.group())
            question = str(data['question'])[:300]
            options = [str(opt)[:55] for opt in data['options'][:10]]
            if len(options) >= 2:
                return {'question': question, 'options': options}
        except (json.JSONDecodeError, KeyError):
            pass

    return None


def handle_poll(task, target, channel_id):
    """
    Handle a POLL task.

    If question and options are provided, uses them directly.
    Otherwise, generates them via LLM using the task description/content as prompt.

    Args:
        task: The task object from DynamoDB
        target: The resolved target (drone ID or user ID)
        channel_id: The Discord channel ID to post in

    Returns:
        dict with success status and any response data
    """
    payload = task.get('payload', {})
    question = payload.get('question', '')
    options = payload.get('options', [])
    duration_hours = payload.get('duration_hours', 24)
    assignee = task.get('assignee', 'void-mother')
    task_id = task.get('task_id', 'unknown')

    # Convert any Decimals
    duration_hours = int(duration_hours) if duration_hours else 24
    options = convert_decimals(options)

    # If question/options not provided, generate via LLM
    if not question or not options:
        content_prompt = payload.get('content', '') or task.get('description', '')

        if not content_prompt:
            return {
                'success': False,
                'error': 'No poll question or content prompt provided'
            }

        logger.info(f"Generating poll content via LLM for task {task_id}")
        generated = generate_poll_content(task, target, content_prompt, assignee)

        if not generated.get('success'):
            return generated  # Return the error

        question = generated.get('question', question)
        options = generated.get('options', options)

    if not question:
        return {
            'success': False,
            'error': 'No poll question provided'
        }

    if not options or len(options) < 2:
        return {
            'success': False,
            'error': 'Poll requires at least 2 options'
        }

    if len(options) > 10:
        return {
            'success': False,
            'error': 'Poll cannot have more than 10 options'
        }

    # Polls can't be created in DMs
    channel_type = task.get('channel', 'dm')
    if channel_type in ('dm', 'group-dm'):
        return {
            'success': False,
            'error': 'Cannot create poll in DM channels'
        }

    if not channel_id:
        return {
            'success': False,
            'error': 'No channel_id available'
        }

    # Send to dronebot HTTP endpoint
    try:
        result = send_poll_to_dronebot(
            channel_id=channel_id,
            question=question,
            options=options,
            duration_hours=duration_hours,
            agent_id=assignee,
            task_id=task_id,
            target=target
        )

        if result.get('success'):
            logger.info(f"Poll created for task {task_id}, message_id={result.get('message_id')}")
            return {
                'success': True,
                'agent': assignee,
                'message_id': result.get('message_id'),
                'question': question,
                'option_count': len(options)
            }
        else:
            error_msg = result.get('error', 'Unknown poll error')
            logger.error(f"Failed to create poll: {error_msg}")
            return {'success': False, 'error': f'Poll creation error: {error_msg}'}

    except Exception as e:
        logger.error(f"Failed to send poll to dronebot: {e}")
        return {'success': False, 'error': f'HTTP error: {str(e)}'}


def send_poll_to_dronebot(channel_id, question, options, duration_hours, agent_id, task_id, target):
    """
    Send poll request to dronebot HTTP endpoint.

    Args:
        channel_id: Discord channel ID
        question: Poll question
        options: List of poll options
        duration_hours: Poll duration in hours
        agent_id: Agent that creates the poll
        task_id: Task ID for logging
        target: Target user

    Returns:
        dict with success status and message_id if successful
    """
    if not DRONEBOT_URL:
        return {'success': False, 'error': 'DRONEBOT_URL not configured'}

    if not DRONEBOT_TOKEN:
        return {'success': False, 'error': 'DRONEBOT_API_TOKEN not configured'}

    payload = json.dumps({
        'agent_id': agent_id,
        'channel_id': channel_id,
        'question': question,
        'options': options,
        'duration_hours': duration_hours,
        'task_id': task_id,
        'target': target
    }).encode('utf-8')

    url = f"{DRONEBOT_URL}/task/poll"
    logger.info(f"Creating poll via {url}")

    req = urllib.request.Request(
        url,
        data=payload,
        headers={
            'Content-Type': 'application/json',
            'X-Dronebot-Token': DRONEBOT_TOKEN
        },
        method='POST'
    )

    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            result = json.loads(resp.read().decode('utf-8'))
            return result
    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8') if e.fp else str(e)
        logger.error(f"HTTP error {e.code}: {error_body}")
        return {'success': False, 'error': f'HTTP {e.code}: {error_body}'}
    except urllib.error.URLError as e:
        logger.error(f"URL error: {e.reason}")
        return {'success': False, 'error': f'Connection error: {e.reason}'}
